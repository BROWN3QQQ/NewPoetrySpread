# 开发

### 注意
1. 移动到服务器端时修改配置,手动创建目录(程序不会自动检查目录是否存在)
2. 在上传工具包里使用了类型强转,第21行,不知道会不会有错(结果有错...MultipartFile不能直接转为File)
3. 多线程上传,估计会出现不同步的问题,服务端收到的文件可能不是1,2,3这样的顺序,但是使用RandomAccessFile可以避免这个问题
4. 注意Long offset = fileChunk.getIndex() * fileChunk.getChunkSize();,前端的序列应该是从0开始
5. 靠文件前缀名获取信息是不可靠的,前后端传递的信息要尽量明确,没必要再进行加工处理
6. 文件上传的目录有问题,目录总是在项目的根目录下的,难道没法在其他目录创建文件吗
7. 文件同名问题,若不巧两个文件就是一样,那怎么办呢,加上时间吧
8. 是不是没必要校验文件片的一致性呢 不需要
9. 不使用乐观锁,mongo出现第二类更新丢失问题,所以,问题的解决方案有两种,
一,给文档加读锁,在修改完成之前不让其他线程读取
二,使用乐观锁,如果发现数据不是最新的就重试
三,使用redis
四,将取出的FileMsg对象放在内存中,并设为线程安全的,再对这个对象进行修改
## 注意
1. 没有提供用来暂停任务的接口,是因为此功能不需要服务端的支持
2. id地址为
3. 
# 接口文档
1. 准备上传
* url:file,方法:POST
* 说明:上传文件之前调用,将一些必要的信息传入服务器
* 参数
```
{
    fileName:xxx,//源文件名
    fileSize:n,//源文件大小,单位为B
    chunkNum:n,//文件应该被拆分为几块,若不分块,值为1
    sourceFileMD5:12312312ab,//源文件的md5值
    chunkSize:n//文件块大小,单位为B
}
```
* 返回值,三种可能
1. 成功,返回数据为上传任务的id,之后每次上传文件块都需要携带该id,id是一个字符串,24位长
2. 失败,返回错误信息
3. 惊喜,服务器上已经有同样的文件,秒传GET,返回文件名(以后会跟前端约定统一的文件地址,地址+文件名,即可访问文件)

二.上传文件块
* url:file/chunk,方法:POST
* 说明:用于上传文件块,当所有文件块上传完毕,后端会返回操作结果和数据,若不分块,同样也是调用这个接口
* 参数
```
{
    id:asdasdasdsd,//字符串
    file:file,
    chunk:n//正在上传第几个文件块
}
```
* 返回值,5种情况
1. 一个失败 状态码006
2. 全部失败 状态码005
3. 全部成功 状态码004
4. 一个成功 状态码003
5. id不存在,也就是任务不存在,状态码998

三.继续上传
* url:file/unfinished/{id}/{name},方法:GET
* 说明:获取哪些文件块没有被上传,以及任务的id
* 返回值:未上传的文件块,以及任务的id

四.删除任务
* url:file,方法:DELETE
* 说明:用于取消任务,服务端会删除此任务的任何信息
* 参数:任务的id
* 返回值,两种情况,成功或者任务不存在
